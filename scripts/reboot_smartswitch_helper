#!/bin/bash

declare -r GNMI_PORT=50052
declare -r MODULE_REBOOT_DPU="DPU"
declare -r MODULE_REBOOT_SMARTSWITCH="SMARTSWITCH"

# Function to check if running on smart switch
function is_smartswitch()
{
    return $(python3 -c "from utilities_common.chassis import is_smartswitch; is_smartswitch()")
}

# Function to check if running on DPU
function is_dpu()
{
    return $(python3 -c "from utilities_common.chassis import is_dpu; is_dpu()")
}

# Function to retrieve number of DPUs
function get_num_dpu()
{
    return $(python3 -c "from utilities_common.chassis import get_num_dpu; get_num_dpus()")
}

# Function to retrieve DPU IP from CONFIG_DB
function get_dpu_ip()
{
    local DPU_NAME=$1
    dpu_ip=$(sonic-db-cli CONFIG_DB HGET "DHCP_SERVER_IPV4_PORT|bridge-midplane|${DPU_NAME}" "ips@")
    if [ $? -ne 0 ] || [ -z "$dpu_ip" ]; then
        echo "Error: Failed to retrieve DPU IP address for ${DPU_NAME}"
        return ${EXIT_ERROR}
    fi
    debug "$DPU_NAME ip: $dpu_ip"
}

# Function to retrieve GNMI port from CONFIG_DB
function get_gnmi_port() {
    local DPU_NAME=$1
    port=$(sonic-db-cli CONFIG_DB HGET "DPU_PORT|$DPU_NAME" "gnmi")
    if [ $? -ne 0 ] || [ -z "$port" ]; then
        debug "Error: Failed to retrieve GNMI port"
        port=$GNMI_PORT  #Hardcoded default GNMI port
        return ${EXIT_ERROR}
    fi
    debug "$DPU_NAME GNMI port:$port"
}

# Function to get reboot status from DPU
function get_reboot_status()
{
    local dpu_ip=$1
    local port=$2
    reboot_status=$(docker exec -i gnmi gnoi_client -target ${dpu_ip}:${port} -logtostderr -insecure -rpc RebootStatus)
    if [ $? -ne 0 ] || [ -z "$reboot_status" ]; then
        echo "Error: Failed to send reboot status command to DPU ${DPU_NAME}"
        return ${EXIT_ERROR}
    fi
    debug "$reboot_status"
}

# Function to retrieve DPU bus info from platform JSON
function get_dpu_bus_info() {
    local DPU_NAME=$1
    DPU_BUS_INFO=$(jq -r --arg DPU_NAME "${DPU_NAME}" '.DPUS[] | select(has($DPU_NAME)) | .[$DPU_NAME].bus_info' "$PLATFORM_JSON_PATH")
    if [ -z "$DPU_BUS_INFO" ]; then
        echo "Error: bus_info not found for DPU ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi
    debug "$DPU_NAME : $DPU_BUS_INFO"
}

#Function to detach PCI module
function pci_detach_module() {
    local DPU_NAME=$1

    status = $(python3 -c "import reboot_helper; reboot_helper.pci_detach_module('${DPU_NAME}')")
    if [ -z "$status" ] || [ "$status" = "false" ]; then
        # Check if DPU exists and retrieve bus info
        DPU_BUS_INFO=$(get_dpu_bus_info "${DPU_NAME}")
        echo 1 > /sys/bus/pci/devices/${DPU_BUS_INFO}/remove
    fi
}

#Function to rescan PCI module
function pci_reattach_module() {
    local DPU_NAME=$1

    status = $(python3 -c "import reboot_helper; reboot_helper.pci_reattach_module('${DPU_NAME}')")
    if [ -z "$status" ] || [ "$status" = "false" ]; then
        echo 1 > /sys/bus/pci/rescan
    fi
}

# Function to reboot DPU
function reboot_dpu_platform() {
    local DPU_NAME=$1
    local REBOOT_TYPE=$2

    local reboot_status=$(python3 -c "import reboot_helper; reboot_helper.reboot_dpu('${DPU_NAME}', '${REBOOT_TYPE}')")
    if [ -z "$reboot_status" ] || [ "$reboot_status" = "false" ]; then
        echo "Error: Failed to reboot the DPU"
        return ${EXIT_ERROR}
    fi
}

#Function to wait for DPU reboot status
function wait_for_dpu_reboot_status() {
    local dpu_ip=$1
    local port=$2

    # Retrieve dpu_halt_services_timeout value using jq
    local dpu_halt_services_timeout=$(jq -r '.dpu_halt_services_timeout' "$PLATFORM_JSON_PATH" 2>/dev/null)
    if [ $? -ne 0 ]; then
        echo "Error: Failed to retrieve dpu_halt_services_timeout from ${PLATFORM_JSON_PATH}"
        return ${EXIT_ERROR}
    fi

    # Poll on reboot status response with a timeout mechanism
    local poll_interval=5
    local waited_time=0
    local reboot_status
    while true; do
        reboot_status=$(get_reboot_status "${dpu_ip}" "${port}")
        debug "GNOI RebootStatus response ${reboot_status}"
        is_reboot_active=$(echo "$reboot_status" | grep "active" | awk '{print $2}')
        if [ "$is_reboot_active" == "false" ]; then
            break
        fi

        sleep "$poll_interval"
        waited_time=$((waited_time + poll_interval))
        if [ $waited_time -ge $dpu_halt_services_timeout ]; then
            echo "Error: Timeout waiting for DPU ${DPU_NAME} to finish rebooting"
            return ${EXIT_ERROR}
        fi
    done
}

# Function to send reboot command to DPU
function gnmi_reboot_dpu()
{
    # Retrieve DPU IP and GNMI port
    dpu_ip=$(get_dpu_ip "${DPU_NAME}")
    port=$(get_gnmi_port "${DPU_NAME}")

    if [ -z "$dpu_ip" ] || [ -z "$port" ]; then
        echo "Error: Failed to retrieve DPU IP or GNMI port for ${DPU_NAME}"
        return ${EXIT_ERROR}
    fi

    docker exec -i gnmi gnoi_client -target ${dpu_ip}:${port} -logtostderr -insecure -rpc Reboot -jsonin '{"method":3}'
    if [ $? -ne 0 ]; then
        echo "Error: Failed to send reboot command to DPU ${DPU_NAME}"
        return ${EXIT_ERROR}
    fi

    wait_for_dpu_reboot_status "${dpu_ip}" "${port}"
}

function reboot_dpu()
{
    local DPU_NAME=$1
    local REBOOT_TYPE=$2
    local DPU_INDEX=${DPU_NAME//[!0-9]/}

    debug "User requested rebooting device ${DPU_NAME} ..."

    # Send reboot command to DPU
    gnoi_reboot_dpu "${dpu_ip}" "${port}"

    # Update STATE_DB and handle PCIe removal and rescan
    sonic-db-cli state_db set "PCIE_DETACH_INFO|${DPU_NAME}" '{"dpu_id": "'${DPU_INDEX}'", "dpu_state": "detaching", "bus_info": "'${DPU_BUS_INFO}'"}'

    pci_detach_module "${DPU_NAME}"
    reboot_dpu_platform "${DPU_NAME}"
    pci_reattach_module "${DPU_NAME}"

    sonic-db-cli state_db del "PCIE_DETACH_INFO|${DPU_NAME}"
}

# Function to reboot all DPUs in parallel
function reboot_all_dpus() {
    local NUM_DPU=$1

    if [[ -z $NUM_DPU ]]; then
        echo "Error: Failed to retrieve number of DPUs or no DPUs found"
        return
    fi

    for (( i=0; i<"$NUM_DPU"; i++ )); do
        echo "Rebooting DPU module dpu$i"
        reboot_dpu "dpu$i" "$MODULE_REBOOT_SMARTSWITCH" &
    done
    wait
}

# Function to verify DPU module name
function verify_dpu_module_name() {
    local DPU_MODULE_NAME=$1
    local NUM_DPU=$2

    if [[ -z "$DPU_MODULE_NAME" ]]; then
        echo "Error: DPU module name not provided"
        return $EXIT_ERROR
    fi

    NUM_DPU=$((NUM_DPU - 1))
    if [[ ! "$DPU_MODULE_NAME" =~ ^dpu[0-$NUM_DPU]$ ]]; then
        echo "Error: Invalid DPU module name provided"
        return $EXIT_ERROR
    fi
}

# Function to handle scenarios on smart switch
function handle_smart_switch() {
    local REBOOT_DPU=$1
    local PRE_SHUTDOWN=$2
    local DPU_NAME=$3

    NUM_DPU=$(get_num_dpu)

    if [[ "$REBOOT_DPU" == "yes" ]]; then
        if [[ "$PRE_SHUTDOWN" == "yes" ]]; then
            echo "Invalid, '-p' option specified"
            return $EXIT_ERROR
        fi

        if is_smartswitch; then
           if [[ -z $NUM_DPU ]]; then
               echo "Error: Failed to retrieve number of DPUs or no DPUs found"
               return $EXIT_ERROR
            fi

            DPU_MODULE_NAME="${DPU_NAME,,}"
            verify_dpu_module_name "$DPU_MODULE_NAME" "$NUM_DPU"

            echo "User requested to reboot the device ${DPU_MODULE_NAME}"
            reboot_dpu "$DPU_MODULE_NAME" "$MODULE_REBOOT_DPU"
        else
            echo "Invalid '-d' option specified for a non-smart switch"
            return $EXIT_ERROR
        fi
    fi

    debug "Is the platform DPU: $(is_dpu)"

    # Check if system is a DPU and handle -p option accordingly
    if is_dpu; then
        if [[ "$PRE_SHUTDOWN" != "yes" ]]; then
            echo "Invalid, '-p' option not specified for a DPU"
            return ${EXIT_ERROR}
        elif [[ "$PRE_SHUTDOWN" == "yes" ]]; then
            echo "Invalid '-p' option specified for a non-DPU"
            return ${EXIT_ERROR}
        fi
        return ${EXIT_SUCCESS}
    fi

    # If the system is a smart switch, reboot all DPUs in parallel
    if is_smartswitch; then
        reboot_all_dpus "$NUM_DPU" "$MODULE_REBOOT_SMARTSWITCH"
    fi
}
